
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAdmin() {
      // Ensure the user document exists before checking the role
      return request.auth != null && exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    function isUser(userId) {
      return request.auth != null && request.auth.uid == userId;
    }
    
    function isPatientListingOwnAppointments(userId, queryOffset, queryLimit) {
      let expectedFields = ["patientId"];
      let actualFields = request.query.filters.map(f => f[0]);

      return request.auth.uid == userId &&
             request.query.filters.size() >= 1 && // Must filter by patientId, may have others like date for sorting
             actualFields.includes("patientId") && 
             request.query.filters.find(f => f[0] == "patientId")[2] == userId && // Ensure patientId filter is for the current user
             (queryLimit == null || queryLimit <= 100); // Allow reasonable limit for own appointments
    }

    function isCheckingSlotAvailability(userId, queryLimit) {
      let expectedFields = ["doctorId", "date"];
      let actualFields = request.query.filters.map(f => f[0]);
      
      return request.auth.uid == userId && // Any authenticated user can check slots
             request.query.filters.size() == 2 &&
             expectedFields.every(field => actualFields.includes(field)) &&
             actualFields.every(field => expectedFields.includes(field)) &&
             queryLimit == 300; // Specific limit for this query type
    }

    function isPatientFetchingOwnSlotTokenCount(userId, query) {
      let expectedFields = ["doctorId", "date", "appointmentTime", "slotConfigId"];
      let actualFields = query.filters.map(f => f[0]);

      return request.auth.uid == userId &&
             query.filters.size() == 4 &&
             expectedFields.every(field => actualFields.includes(field)) &&
             actualFields.every(field => expectedFields.includes(field)) &&
             (query.limit == null || query.limit <= 50); // Limit for counting existing tokens in a slot
    }

    // Users collection
    match /users/{userId} {
      allow read: if isUser(userId) || isAdmin();
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid; // User can create their own doc
      allow update: if isUser(userId) || isAdmin(); // User can update their own doc, admin can update any
      allow delete: if isAdmin();
    }

    // Doctors collection
    match /doctors/{doctorId} {
      allow read: if request.auth != null; // All authenticated users can read doctor profiles
      allow list: if request.auth != null; // All authenticated users can list doctors
      allow create, update, delete: if isAdmin(); // Only admins can manage doctors
    }

    // Slot Configurations collection
    match /slotConfigurations/{slotConfigId} {
      allow read, list: if request.auth != null; // All authenticated users can read/list slot configs for booking
      allow create, update, delete: if isAdmin(); // Only admins can manage slot configurations
    }
    
    // Appointments collection
    match /appointments/{appointmentId} {
      allow read: if (request.auth != null && resource.data.patientId == request.auth.uid) || isAdmin();
      allow list: if (isPatientListingOwnAppointments(request.auth.uid, request.query.offset, request.query.limit)) ||
                     (isCheckingSlotAvailability(request.auth.uid, request.query.limit)) ||
                     (isPatientFetchingOwnSlotTokenCount(request.auth.uid, request.query)) || // New rule for token query
                     isAdmin();
      allow create: if isUser(request.auth.uid) &&
                       request.resource.data.patientId == request.auth.uid &&
                       request.resource.data.status == "upcoming" &&
                       request.resource.data.tokenNumber > 0 && 
                       hasAll(request.resource.data.keys(), ['patientId', 'patientName', 'doctorId', 'doctorName', 'date', 'time', 'appointmentTimeDisplay', 'slotConfigId', 'tokenNumber', 'createdAt', 'specialization', 'status']);
      allow update: if (isUser(request.auth.uid) && 
                        request.resource.data.patientId == request.auth.uid && 
                        (request.resource.data.status == "cancelled" || request.resource.data.status == resource.data.status)) || // Patient can cancel or if status unchanged
                       isAdmin(); // Admin can update any appointment
      allow delete: if isAdmin();
    }

    // Tests collection
    match /tests/{testId} {
      allow read, list: if request.auth != null; // All authenticated can read/list tests
      allow create, update, delete: if isAdmin(); // Only admins can manage tests
    }

    // Bills collection (Placeholder, assuming only admins manage for now)
    match /bills/{billId} {
      allow read, list, create, update, delete: if isAdmin();
    }
    
    // Clinic Configuration collection
    match /clinicConfiguration/{configId} {
      allow read: if request.auth != null; // All authenticated can read clinic config (e.g. name, address)
      allow write: if isAdmin(); // Only admins can change clinic config
    }
    
    // User Settings collection
    match /userSettings/{userSettingId} {
      // ID should be userPrefs_{userId}
      allow read, write: if request.auth != null && request.auth.uid == userSettingId.split('_')[1];
    }
    
    // Doctor Queue Status
    match /doctorQueueStatus/{doctorId} {
        allow read: if request.auth != null; // Any authenticated user can read live queue status
        allow write: if isAdmin(); // Only admin (or a trusted server/function) should update this
    }
  }
}
